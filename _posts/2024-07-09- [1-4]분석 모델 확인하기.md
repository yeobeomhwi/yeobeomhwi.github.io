---
title: "SECTION 1-3 : 분석 모델 확인하기(2)"
date: "2024-07-09"
categories: [정보처리기사]
tags:
    - 정보처리기사 
    - SECTION 1
---

# SECTION 1-3 - 분석 모델 확인하기(2)

## 다이어그램

### 정적 다이어그램
시스템의 정적인 부분을 가시화하기 위해 다이어그램을 이용하여 표현한 것이다.

|이름|설명|
|:---:|:---|
|클래스 다이어그램<br>(Class Diagram)|	시스템을 구성하는 클래스와 인터페이스 사이의 정적인 관계를 나타냄. 주요 시스템 구조를 파악하고 구조상의 문제점을 도출.|
|객체 다이어그램<br> (Object Diagram)|	클래스 다이어그램에 포함된 사물들의 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현.|
|컴포넌트 다이어그램<br> (Component Diagram)|	실제 구현 모듈인 컴포넌트 간의 관계를 표현.|
|배치 다이어그램<br> (Deployment Diagram)|	노드와 노드 사이에 존재하는 컴포넌트들의 물리적인 구성을 표현.|

### 암기 문장
* 클래스 다이어그램: "클래스와 인터페이스의 구조"
* 객체 다이어그램: "클래스의 인스턴스 관계"
* 컴포넌트 다이어그램: "구현 모듈 관계"
* 배치 다이어그램: "물리적 구성"

----------------------------

### 동적 다이어그램
시스템의 동적인 부분을 가시화하기 위해 다이어그램을 이용하여 표현한 것이다.

|이름|설명|
|:---:|---|
|유스케이스 다이어그램<br>(Use Case Diagram)|	시스템의 요구사항 중 기능적인 요구사항을 유스케이스 단위로 표현하고 액터(Actor)와 이들 간의 관계를 다이어그램으로 표현.|
|순차 다이어그램<br>(Sequence Diagram)|	시스템의 내부적인 로직 흐름을 동적으로 표현한 다이어그램으로, 객체와 객체 사이의 관계와 객체들끼리 상호 교환하는 메시지의 순서를 강조하여 표현.|
|상태 다이어그램<br>(State Diagram)|시스템의 동적인 상태를 나타내는 다이어그램으로, 이벤트에 따라 순차적으로 발생하는 객체의 상태 변화를 표현.|
|활동 다이어그램<br>(Activity Diagram)|시스템의 내부 활동에 대한 흐름을 행위에 따라 변화하는 객체의 상태를 표현하는 다이어그램.|

### 암기 문장
* 유스케이스 다이어그램: "기능 요구사항, 액터 관계"
* 순차 다이어그램: "메시지 순서, 로직 흐름"
* 상태 다이어그램: "이벤트, 상태 변화"
* 활동 다이어그램: "행위 흐름, 상태 변화"

--------------------------

## 디자인 패턴의 분류와 종류

### 객체 생성을 위한 패턴

|이름|설명|
|---|---|
|Factory Method	|객체 생성을 서브 클래스에 위임, 대행 함수를 통해 인스턴스 생성 결정.|
|Abstract Factory | 관련 제품군의 객체를 생성, 제품군별 객체 생성.|
|Singleton | 하나의 클래스 인스턴스만 생성, 전역적으로 접근 가능.|
|Prototype | 복제를 통해 객체 생성.|
|Builder | 부분 생성을 통해 전체 객체를 생성.|

### 암기 문장
* Factory Method: "서브 클래스가 생성, 대행 함수 사용"
* Abstract Factory: "제품군 객체 생성"
* Singleton: "유일한 인스턴스, 전역 접근"
* Prototype: "복제로 객체 생성"
* Builder: "부분 생성, 전체 객체"

### 구조 개선을 위한 패턴

|이름|설명|
|---|---|
| Adapter | 클라이언트가 기대하는 다른 인턴페이스로 전환|
| Facade | 서브 시스템에 대한 통합된 인터페이스를 제공|
| Bridge | 인터페이스와 구현의 명확한 분리|
| Composite | 객체 간의 부분.전체 관계 형성 및 관리, 재귀적 합성 이용|
| Decorator | 상속없이 객체의 기능을 동적으로 추가.삭제(Overloading)|
| Flyweight | 작은 객체들의 공유|
| Proxy | 대체(대리자) 객체를 통한 작업 수행|

### 암기 문장
* Adapter: "인터페이스 변환, 클라이언트 기대 충족"
* Facade: "통합된 인터페이스 제공"
* Bridge: "인터페이스와 구현 분리"
* Composite: "부분-전체 관계 형성"
* Decorator: "동적 기능 추가/삭제, 상속 없음"
* Flyweight: "작은 객체 공유"
* Proxy: "대리자 통한 작업 수행"

### 행위 개선을 위한 패턴

|이름|설명|
|---|---|
|Interpreter|간단한 문법에 기반한 검증작업 및 작업처리.|
|Template Method|상위 클래스에서 기본 골격을 결정, 하위 클래스에서 구체적 내용 정의(Overriding).|
|Command|요청을 객체로 캡슐화, 수행할 작업의 일반화를 통한 조작.|
|Iterator|동일 자료형의 여러 객체 순차 접근.|
|Mediator|객체들 간의 상호작용을 객체로 캡슐화, 다대다 객체 관계를 다대일로 단순화.|
|Memento|객체의 이전 상태 복원 또는 보관.|
|Observer|일대다의 객체 의존관계를 정의.|
|State|객체 상태 추가 시 행위 수행의 원활한 변경.|
|Strategy|동일 목적의 여러 알고리즘 중 선택해서 적용.|
|Visitor|오퍼레이션이 처리할 요소의 클래스를 변경하지 않고도 새로운 오퍼레이션을 정의.|
|Chain of Responsibility|수행 가능 객체군까지 요청 전파.|

### 암기 문장
* Interpreter: "문법 검증 및 작업 처리"
* Template Method: "기본 골격 결정, 구체적 내용 정의"
* Command: "요청을 객체로 캡슐화"
* Iterator: "여러 객체 순차 접근"
* Mediator: "상호작용을 객체로 캡슐화"
* Memento: "이전 상태 복원"
* Observer: "일대다 객체 의존관계"
* State: "상태 추가 시 원활한 변경"
* Strategy: "여러 알고리즘 선택 적용"
* Visitor: "클래스 변경 없이 새로운 오퍼레이션"
* Chain of Responsibility: "요청 전파, 수행 가능 객체까지"