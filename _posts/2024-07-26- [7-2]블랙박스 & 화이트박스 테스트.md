---
title: "SECTION 7-2 블랙박스 & 화이트박스"
date: "2024-07-26"
categories: [정보처리기사, SECTION _7]
tags:
    - 정보처리기사 
    - SECTION 7
---
## 블랙박스 테스트 

### 정의 및 특징

1. **블랙박스 테스트**는 프로그램의 **논리(알고리즘)**을 고려하지 않고, 프로그램의 기능이나 인터페이스에 관한 **외부 명세**로부터 직접 테스트하여 데이터를 선정하는 방법임.
2. **기능 테스트**, **데이터 위주(Data-Driven) 테스트**, **입출력 위주(IO-Driven) 테스트**를 포함함.
3. 이 방법은 소프트웨어의 **기능적 요구사항**에 초점을 맞춤.
4. 프로그램의 논리나 알고리즘과는 상관없이 **기초적 시스템 모델의 관점**임.

### 블랙박스 테스트에서 찾고자 하는 오류

1. **부정확하고 누락된 기능**
2. **인터페이스 오류**
3. **자료구조나 외부 데이터베이스 접근**에 있는 오류
4. **성능 오류**
5. **초기화와 종료 오류**

### 블랙박스 테스트의 기법

1. **동등 분할 (Equivalence Partitioning, 균등 분할, 동치 분할)**
   - 프로그램의 **입력 도메인**을 테스트 사례가 산출될 수 있는 데이터의 클래스로 분류하여 테스트 사례를 만들어 검사하는 방법.
   - 프로그램의 **입력 조건**을 중심으로 타당한 값과 그렇지 못한 값을 설정하여 각 **동등 클래스** 내의 임의의 값을 테스트 사례로 선정.
     - **유효 동등 클래스 집합**: 프로그램에 유효한 입력을 가진 테스트 사례.
     - **무효 동등 클래스 집합**: 프로그램에 타당하지 못한 입력을 가진 테스트 사례.
   - 각 클래스에 **최소한의 테스트 사례**를 만드는 것이 중요.

2. **경계값 분석 (Boundary Value Analysis)**
   - **입력 조건**의 중간값보다는 **경계값**에서 오류가 발생할 확률이 높다는 점을 이용하여 경계값에서 테스트 사례를 선정.
   - 입력 자료에만 치중한 **동등 분할 기법**을 보완하기 위한 기법.
   - 입력 조건과 출력 조건을 테스트 사례로 선정.
   - 입력 조건이 \([a, b]\)와 같이 값의 범위를 명시할 때, \(a, b\) 값뿐만 아니라 \([a, b]\)의 범위를 약간 벗어나는 값들을 테스트 사례로 선정함. 즉, 입력 조건이 특정한 수를 나타낼 경우 **최댓값, 최솟값, 최댓값보다 약간 큰 값, 최솟값보다 약간 작은 값**들을 선정함.

3. **원인 - 결과 그래프 기법 (Cause-Effect Graph)**
   - 입력 데이터 간의 **관계**가 출력에 미치는 **상황을 체계적으로 분석**하여 효용성 높은 테스트 사례를 추출하여 시험하는 기법.
   - 프로그램의 **외부 명세**에 의한 입력 조건(원인)과 그 입력으로 발생되는 출력(결과)을 **논리적으로 연결**시킨 **그래프**로 표현하여 테스트 사례를 유도해 냄.
   - 여러 입력 조건의 **조합으로 한 개 이상의 결과**를 얻을 수 있는 테스트 사례를 추출 가능.

4. **오류 추측 (Error-Guessing) 기법**
   - 다른 블랙박스 테스트 기법들이 놓칠 수 있을 만한 **오류를 감각과 경험으로** 찾아내는 일련의 보충적 테스트 기법.
   - **2세대 인터페이스**의 **명령어 중심적 시스템**에 적용.
   - 세부화된 **알고리즘이 존재하지 않음**.

5. **비교 검사 (Comparison Testing) 기법**
   - 블랙박스 테스트 기법의 기초로 **Back-to-Back 테스트**라고 함.
   - 소프트웨어의 **신뢰성이 절대적으로 중요한 경우** 똑같은 기능의 소프트웨어를 개발하여 비교.
   - 테스트의 **일관성을 보장**하기 위해 동일한 테스트 자료를 제공하여 두 시스템의 결과가 같은지 **동시에 실시간 비교**하면서 진행.

## 화이트 박스 테스트

### 정의 및 특징

1. **프로그램 내의 모든 논리적 구조**를 파악하거나, **경로들의 복잡도**를 계산하여 테스트 사례를 만든다.
2. **제어 구조**를 이용하여 테스트 사례를 유도하는 방법이다.
3. **소프트웨어 형상(Configuration)**의 구조를 이용하여 테스트 사례를 만든다.
4. **모든 논리적 경로**를 파악하거나, **경로들의 복잡도**를 계산하여 테스트 사례를 만든다.

### 이용 범주

1. 모듈 내의 모든 **경로**들이 적어도 **한 번**은 테스트될 수 있도록 보장한다.
2. **참과 거짓** 측면에서 모든 **논리적 경로**가 조사되어야 한다.
3. **경계와 작동 한계**에서의 모든 루프를 실행시키는 테스트이다.
4. **내부 자료구조**의 유효성을 확인하기 위해 테스트 사례를 만든다.

### 수행 절차

1. 테스트 케이스를 만든다.
2. 테스트 결과를 예측하여 **테스트 오라클**을 만든다.
3. 테스트 결과와 테스트 오라클을 비교한다. 결과의 차이가 있다면 변경하고, 변경 후 실시되는 테스트를 **리그레션(Regression) 테스트**라고 한다.

### 화이트박스 테스트의 기법

1. **기초경로 테스트 (Base Path Testing)**
   - 가장 대표적인 화이트박스 기법으로 **McCabe**에 의해 제안됨.
   - **논리 흐름도**를 작성하고, **복잡도**를 측정하여 **경로**를 정의한다.
   - 테스트 사례 설계자가 절차적 설계의 논리적 **복잡도**를 측정하여 이 측정을 **실행 경로**의 기초를 정의하는 데 사용할 수 있게 한다.

2. **루프 테스트 (Loop Testing)**
   - **반복 구조**에 국한하여 실시하는 화이트박스 테스트 기법.
   - **구조 테스트**와 병행 사용이 가능하다.
   - 발견 가능한 오류: **초기화 결함**, **인덱싱 결함**, **경계 결함** 등.
   - 검사 방법:
     - **제어변수**, **초기치**, **증가치**, **최종 조건** 등의 잘못된 기재에 대해 집중적인 검토 실시.
     - **단순 루프**, **중첩 루프**, **연결 루프**, **비구조적 루프**를 구분하여 검사함.
   
   | 구분 | 내용 | 
   | --- | --- |
   | **단순 루프** | \(n\)이 루프가 돌아가는 최대치라고 하면 루프를 0번, 1번, 2번, \(m\)번 (\(m < n\)), \(n-1\)번, \(n\)번, \(n+1\)번 돌아가게 한다. |
   | **중첩 루프** | 가장 안쪽에 있는 루프부터 시험하되 바깥 루프들은 최소치를 유지시키거나, 바깥 루프부터 시작하되 안쪽의 루프는 최소치를 유지하는 시험을 반복시켜 모든 루프가 시험되도록 한다. |
   | **연결(접합) 루프** | 각 루프는 독립적이며, 단순 루프 시험 방식으로 시험한다. |
   | **비구조적 루프** | 가능한 한 구조적 프로그래밍 구조의 사용이 가능하도록 재설계되어야 한다. |

3. **조건 테스트 (Condition Testing)**
   - **모듈 내에 포함된 논리적 조건**을 검사하여 테스트 사례를 설계하는 방법.
   - **각 조건**의 참과 거짓을 테스트하는 데 초점을 맞춘다.

4. **데이터 흐름 테스트 (Data Flow Testing)**
   - **변수 정의의 위치**와 **변수들의 사용**에 따라 검사 경로를 선택하는 방법.

### 화이트박스 테스트 검증 기준

| 구분 | 내용 |
| --- | --- |
| **문장 검증 기준 (Statement Coverage)** | 소스 코드의 모든 **구문**이 **한 번 이상** 수행되도록 테스트 케이스를 설계했는지 검증한다. |
| **분기 검증 기준 (Branch Coverage)** | 소스 코드의 모든 **조건**이 **한 번 이상** 수행되도록 테스트 케이스를 설계했는지 검증한다. 결정 커버리지(Decision Coverage)라고도 하며, **결정(분기) 포인트**는 참과 거짓을 **한 번씩** 나타내야 한다. |
| **조건 검증 기준 (Condition Coverage)** | 소스 코드의 모든 **조건문**의 참과 거짓이 **각 한 번 이상** 수행되도록 테스트 케이스를 설계했는지 검증한다. 각 **개별식**이 참과 거짓을 **한 번씩** 나타내야 한다. |
| **분기/조건 기준 (Branch/Condition Coverage)** | 소스 코드의 모든 **조건문**과 각 조건문에 포함된 **개별 조건식**의 결과가 참과 거짓인 경우 각각을 **한 번 이상** 수행되도록 설계했는지 검증한다. |
