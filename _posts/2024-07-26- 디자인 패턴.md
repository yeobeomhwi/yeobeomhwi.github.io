---
title: "디자인패턴"
date: "2024-07-26"
categories: [정보처리기사, 암기]
tags:
    - 정보처리기사 
---
## 디자인 패턴의 분류와 종류

### 객체 생성을 위한 패턴

1. **Factory Method (팩토리 메소드)**
   - **설명**: 대행 함수(위임)를 통한 **객체 생성**, 인스턴스 생성 결정은 **서브클래스**에서 수행합니다.
   - **사용 목적**: 객체 생성의 책임을 **서브클래스**에 위임하여 **유연성**을 높입니다.

2. **Abstract Factory (추상 팩토리)**
   - **설명**: **제품군**(product family)별 객체를 생성합니다.
   - **사용 목적**: 관련 객체의 집합을 **일관되게** 생성하여 **일관성**을 유지합니다.

3. **Singleton (싱글톤)**
   - **설명**: **클래스 인스턴스**가 하나만 만들어지고 그 인스턴스에 **전역 접근**을 제공합니다.
   - **사용 목적**: 인스턴스의 **유일성**을 보장하고 **글로벌 상태**를 유지합니다.

4. **Prototype (프로토타입)**
   - **설명**: 객체를 **복제**하여 새로운 객체를 생성합니다.
   - **사용 목적**: 객체의 **복사** 및 재사용을 통해 **객체 생성 비용**을 줄입니다.

5. **Builder (빌더)**
   - **설명**: **부분 생성**을 통해 전체 객체를 생성합니다.
   - **사용 목적**: **복잡한 객체**의 생성 과정을 분리하여 **단계별로 객체**를 구성합니다.


>💡ABFPS  
 A : 추상팩토리  
 B : 빌더  
 F : 팩토리메서드  
 P : 프로토타입  
 S : 싱글톤


### 구조 개선을 위한 패턴

1. **Adapter (어댑터)**
   - **설명**: 클라이언트가 기대하는 **인터페이스**로 다른 인터페이스를 전환합니다.
   - **사용 목적**: 기존 인터페이스와의 **호환성**을 제공합니다.

2. **Facade (파사드)**
   - **설명**: **서브시스템**에 대한 **통합된 인터페이스**를 제공합니다.
   - **사용 목적**: 서브시스템의 **복잡성**을 숨기고 간단한 **인터페이스**를 통해 접근합니다.

3. **Bridge (브릿지)**
   - **설명**: **인터페이스**와 **구현**의 명확한 분리를 제공합니다.
   - **사용 목적**: **구현**과 **인터페이스**의 독립적 변경을 가능하게 합니다.

4. **Composite (컴파짓)**
   - **설명**: 객체 간의 **부분·전체 관계**를 형성하고 관리합니다. **재귀적 합성**을 이용합니다.
   - **사용 목적**: **계층 구조**의 복합 객체를 처리합니다.

5. **Decorator (데코레이터)**
   - **설명**: **상속** 없이 객체의 기능을 동적으로 **추가**하거나 **삭제**할 수 있습니다.
   - **사용 목적**: 객체에 **기능**을 유연하게 추가하거나 변경합니다.

6. **Flyweight (플라이웨이트)**
   - **설명**: **작은 객체들**을 공유합니다.
   - **사용 목적**: **메모리 절약**과 **객체 수의 감소**를 통해 **효율성**을 높입니다.

7. **Proxy (프록시)**
   - **설명**: **대체(대리자)** 객체를 통해 작업을 수행합니다.
   - **사용 목적**: 객체 접근을 **제어**하고 추가 작업을 수행합니다.

>💡ABCDFFP  
A : 어댑터  
B : 브릿지  
C : 컴파짓  
D : 데코레이터  
F : 파사드  
F : 플라이웨이트  
P : 프록시   


### 행위 개선을 위한 패턴

1. **Interpreter (인터럽터)**
   - **설명**: **간단한 문법**에 기반한 **검증작업** 및 작업처리를 수행합니다.
   - **사용 목적**: **문법 분석** 및 **처리 기능**을 제공합니다.

2. **Template Method (템플릿 메소드)**
   - **설명**: **상위 클래스**에서 기본 골격을 결정하고, **하위 클래스**에서 구체적 내용을 정의합니다.
   - **사용 목적**: **알고리즘**의 기본 구조를 정의하고 하위 클래스에서 **세부 구현**을 가능하게 합니다.

3. **Command (커맨드)**
   - **설명**: 요청을 **객체로 캡슐화**하고, 수행할 작업을 **일반화**하여 조작합니다.
   - **사용 목적**: 요청의 **인수**와 요청자를 **분리**하고, 요청을 **큐에 저장**하거나 **실행 취소** 기능을 제공합니다.

4. **Iterator (이터레이터)**
   - **설명**: 동일 자료형의 여러 객체를 **순차적으로 접근**합니다.
   - **사용 목적**: **객체 컬렉션**을 순차적으로 접근하고 탐색합니다.

5. **Mediator (미디에이터)**
   - **설명**: 객체들 간의 **상호작용**을 객체로 **캡슐화**하여 **다대다** 객체 관계를 **다대일**로 단순화합니다.
   - **사용 목적**: 객체 간의 **복잡한 상호작용**을 관리하고 조정합니다.

6. **Memento (메멘토)**
   - **설명**: 객체의 **이전 상태**를 복원하거나 보관합니다.
   - **사용 목적**: 객체 상태의 **저장** 및 **복원**을 통해 이전 상태로 되돌리기 기능을 제공합니다.

7. **Observer (옵저버)**
   - **설명**: **일대다**의 객체 **의존관계**를 정의하여 한 객체의 상태 변화 시 여러 객체에 **통지**합니다.
   - **사용 목적**: **상태 변화**에 따른 **자동 통지**를 구현합니다.

8. **State (스테이트)**
   - **설명**: 객체의 **상태**에 따라 행위를 원활하게 **변경**합니다.
   - **사용 목적**: **상태에 따른 행동**을 동적으로 변경합니다.

9. **Strategy (스트레터지)**
   - **설명**: 동일 목적의 여러 **알고리즘** 중 하나를 선택하여 적용합니다.
   - **사용 목적**: **알고리즘**을 동적으로 선택하고 **교체**합니다.

10. **Visitor (비지터)**
    - **설명**: 오퍼레이션이 처리할 **요소의 클래스**를 변경하지 않고도 새로운 오퍼레이션을 정의합니다.
    - **사용 목적**: 객체 **구조**를 변경하지 않고 **새로운 연산**을 추가합니다.

11. **Chain of Responsibility (책임 연쇄)**
    - **설명**: 요청을 **수행 가능 객체군**까지 전파합니다.
    - **사용 목적**: 요청을 처리할 **객체를 연결**하여 요청 처리의 **유연성**을 높입니다.

> 💡 COSMIC'S TIMO  
우주의 티모  
C : Chain of Responsibility (책임 연쇄)   
O : Observer (옵저버)   
S : State (스테이트)  
M : Memento (메멘토)   
I : Interpreter (인터럽터)  
S : Strategy (스트레터지)   
T : Template method  (템플릿 메소드)  
I : Iterator   (이터레이터)  
M : Meditator (미디에이터)  
O : Observer (옵저버 중복)


## 디자인 패턴의 분류와 종류

### 객체 생성을 위한 패턴

| 패턴             | 설명                                                             | 사용 목적                                 |
|------------------|------------------------------------------------------------------|------------------------------------------|
| **Factory Method** | 대행 함수(위임)를 통한 객체 생성, 인스턴스 생성 결정은 서브클래스 | 객체 생성의 책임을 서브클래스에 위임       |
| **Abstract Factory** | 제품군(product family)별 객체 생성                               | 관련 객체의 집합을 일관되게 생성           |
| **Singleton**       | 클래스 인스턴스가 하나만 만들어지고 그 인스턴스의 전역접근         | 인스턴스의 유일성을 보장하고 전역 접근 제공 |
| **Prototype**       | 복제를 통한 객체 생성                                           | 객체의 복사 및 재사용                     |
| **Builder**         | 부분 생성을 통한 전체 객체 생성                                 | 복잡한 객체의 생성 과정을 분리            |

### 구조 개선을 위한 패턴

| 패턴             | 설명                                                             | 사용 목적                                  |
|------------------|------------------------------------------------------------------|-------------------------------------------|
| **Adapter**        | 클라이언트가 기대하는 다른 인터페이스로 전환                     | 기존 인터페이스와의 호환성 제공            |
| **Facade**         | 서브시스템에 대한 통합된 인터페이스를 제공                       | 서브시스템의 복잡성을 숨기고 간단한 인터페이스 제공 |
| **Bridge**         | 인터페이스와 구현의 명확한 분리                                 | 구현과 인터페이스의 독립적 변경           |
| **Composite**      | 객체 간의 부분·전체 관계 형성 및 관리, 재귀적 합성 이용            | 계층 구조의 복합 객체 처리                 |
| **Decorator**      | 상속 없이 객체의 기능을 동적으로 추가·삭제(overloading)          | 객체에 기능을 유연하게 추가                |
| **Flyweight**      | 작은 객체들의 공유                                               | 메모리 절약 및 객체 수의 감소              |
| **Proxy**          | 대체(대리자) 객체를 통한 작업 수행                               | 객체 접근을 제어하고 추가 작업 수행       |

### 행위 개선을 위한 패턴

| 패턴               | 설명                                                             | 사용 목적                                 |
|--------------------|------------------------------------------------------------------|------------------------------------------|
| **Interpreter**    | 간단한 문법에 기반한 검증작업 및 작업처리                          | 문법 분석 및 처리                         |
| **Template Method**| 상위클래스에서 기본 골격을 결정, 하위클래스에서 구체적 내용 정의    | 알고리즘의 기본 구조를 정의하고 하위클래스에서 세부 구현 |
| **Command**        | 요청을 객체로 캡슐화, 수행할 작업의 일반화를 통한 조작              | 요청의 인수 및 요청자의 분리              |
| **Iterator**       | 동일 자료형의 여러 객체 순차 접근                                | 객체 컬렉션의 순차 접근                    |
| **Mediator**       | 객체들 간의 상호작용을 객체로 캡슐화. 다대다 객체 관계를 다대일로 단순화. | 객체 간의 복잡한 상호작용 관리            |
| **Memento**        | 객체의 이전 상태 복원 또는 보관                                   | 객체 상태의 저장 및 복원                 |
| **Observer**       | 일대다의 객체 의존관계를 정의                                     | 객체 상태 변화 시 자동 통지               |
| **State**          | 객체 상태 추가시 행위 수행의 원활한 변경                          | 상태에 따라 객체의 행동 변경              |
| **Strategy**       | 동일 목적의 여러 알고리즘 중 선택해서 적용                        | 알고리즘의 동적 교체 및 선택              |
| **Visitor**        | 오퍼레이션이 처리할 요소의 클래스를 변경하지 않고도 새로운 오퍼레이션을 정의 | 객체 구조를 변경하지 않고 연산 추가       |
| **Chain of Responsibility** | 수행 가능 객체군까지 요청 전파                                 | 요청을 처리할 객체를 연결하여 처리       |
